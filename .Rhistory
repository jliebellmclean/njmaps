) +
labs(title = "New Jersey Counties") +
theme_minimal() +
theme(
legend.position = "none",
axis.text = element_blank(),                # remove axis text
axis.ticks = element_blank(),               # remove axis ticks
axis.title = element_blank(),               # remove gridlines
panel.grid.major = element_blank(),
plot.title       = element_text(size = 16, face = "bold")) +
scale_fill_manual(values = map_colors)
p <- ggplot(county) +
geom_sf(aes(fill = NAME), color = "white") +
geom_sf_text(
aes(label = NAME),   # label with county name
size = 2.5,
color = "black",
face =
) +
labs(title = "New Jersey Counties") +
theme_minimal() +
theme(
legend.position = "none",
axis.text = element_blank(),                # remove axis text
axis.ticks = element_blank(),               # remove axis ticks
axis.title = element_blank(),               # remove gridlines
panel.grid.major = element_blank(),
plot.title = element_text(size = 16, face = "bold")
) +
scale_fill_manual(values = map_colors)
p <- ggplot(county) +
geom_sf(aes(fill = NAME), color = "white") +
geom_sf_text(
aes(label = NAME),   # label with county name
size = 2.5,
color = "black",
face = "bold"
) +
labs(title = "New Jersey Counties") +
theme_minimal() +
theme(
legend.position = "none",
axis.text = element_blank(),                # remove axis text
axis.ticks = element_blank(),               # remove axis ticks
axis.title = element_blank(),               # remove gridlines
panel.grid.major = element_blank(),
plot.title = element_text(size = 16, face = "bold")
) +
scale_fill_manual(values = map_colors)
p
ggsave("figures/county-color.png", plot = p, width = 4, dpi = 300)
# Specify which years we are interested in
years <- c(2000, 2004, 2008, 2012, 2016, 2020)
# Select the interesting categories
pres <- pres_elections_release |>
select(election_year, fips, sfips, office, election_type,
democratic_raw_votes, republican_raw_votes,
pres_raw_county_vote_totals_two_party)
load("data/dataverse_shareable_presidential_county_returns_1868_2020.Rdata")
# Specify which years we are interested in
years <- c(2000, 2004, 2008, 2012, 2016, 2020)
# Select the interesting categories
pres <- pres_elections_release |>
select(election_year, fips, sfips, office, election_type,
democratic_raw_votes, republican_raw_votes,
pres_raw_county_vote_totals_two_party)
# Select for the right years
pres <- pres |>
filter(election_year %in% years)
# Double check that the office and election_type categories are meaningless
# unique(pres$office)
# unique(pres$election_type)
# Yep, they're all "G" and "PRES"
# Drop some columns and filter to NJ only
pres <- pres |>
filter(sfips == 34) |>
select(-office, -election_type)
# Double check that the total two party vote number is correct
# pres1 <- pres |>
# mutate(total = democratic_raw_votes + republican_raw_votes,
# check = pres_raw_county_vote_totals_two_party - total)
# unique(pres1$check)
# Calculate the percent of Democrat and Republican votes and partisan lean
pres2 <- pres |>
mutate(pct_dem = democratic_raw_votes/pres_raw_county_vote_totals_two_party,
pct_rep = republican_raw_votes/pres_raw_county_vote_totals_two_party,
d_points = pct_dem - pct_rep)|>
# Drop everything except the lean, county ID, and the election years
select(election_year, fips, d_points) |>
# Rename the fips code for merging
rename(GEOID = fips)
# Isolate the geometry and fips code
geo <- county |>
select(GEOID, geometry)
# Add on the geometry to the election results
pres2 <- pres2 |>
left_join(geo, by = "GEOID")
# I got the idea for using facet_wrap from Copilot and then adjusted the code.
# Graph the partisan lean in a given year, by county, for NJ
p <- ggplot(pres2, aes(fill = d_points, geometry = geometry)) +
geom_sf(color = "grey2", linewidth = 0.05) +
scale_fill_gradient2(
low = "#CB454A", mid = "white", high = "#2E74C0",
midpoint = 0,
name = "Partisan Lean"
) +
facet_wrap(~ election_year, ncol = 3) +
labs(title = "Partisan Lean in Presidential Elections, 2000–2020") +
theme_minimal() +
theme(
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 16, face = "bold")
)
p
ggsave("figures/pres.png", plot = p, dpi = 300)
load("data/dataverse_shareable_gubernatorial_county_returns_1865_2020.Rdata")
# Double check that the office and election_type categories are meaningless
# unique(pres$office)
# unique(pres$election_type)
# Yep, they're all "G" and "GOV"
# Drop some columns and filter to NJ only
gov <- gov_elections_release |>
filter(sfips == 34) |>
select(-office, -election_type)
# Specify which years we are interested in
years <- c(2005, 2007, 2009, 2013, 2017)
# Select the interesting categories
gov <- gov |>
select(election_year, fips, sfips,
democratic_raw_votes, republican_raw_votes,
gov_raw_county_vote_totals_two_party)
# Select for the right years
gov <- gov |>
filter(election_year %in% years)
# Calculate the percent of Democrat and Republican votes and partisan lean
gov2 <- gov |>
mutate(pct_dem = democratic_raw_votes/gov_raw_county_vote_totals_two_party,
pct_rep = republican_raw_votes/gov_raw_county_vote_totals_two_party,
d_points = pct_dem - pct_rep)|>
# Drop everything except the lean, county ID, and the election years
select(election_year, fips, d_points) |>
# Rename the fips code for merging
rename(GEOID = fips)
# Isolate the geometry and fips code
geo <- county |>
select(GEOID, geometry)
# Add on the geometry to the election results
gov2 <- gov2 %>%
left_join(geo, by = "GEOID")
# Add in information from 2021 and 2025
# I pulled information from the NJ state website:
# https://www.nj.gov/state/elections/election-night-results.shtml
# For 2025, I was redirected to the County Clerk websites for all counties
# I pulled that information
# I then corroborated the numbers against the AP's reported results. They match
gov_updated <- read.csv("data/updated_gov.csv")
# Rename the name category
gov_updated <- gov_updated |>
rename(NAME = county)
# Isolate the county names and fips codes
county_code <- county |>
select(GEOID, NAME) |>
# Merge the GEOIDs onto the new election results
gov_updated <- gov_updated %>%
left_join(county_code, by = "NAME")
gov_updated <- gov_updated %>%
left_join(county_code, by = "NAME")
county_code <- county |>
select(GEOID, NAME) |>
gov_updated <- gov_updated %>%
left_join(county_code, by = "NAME")
county_code <- county |>
select(GEOID, NAME)
# Merge the GEOIDs onto the new election results
gov_updated <- gov_updated %>%
left_join(county_code, by = "NAME")
# Specify all the column names in the cleaned gov2 dataset
colnames(gov2)
gov_updated <- gov_updated |>
# Rename election year
rename(election_year = year) |>
mutate(
# Create a totals column
total = d_votes + r_votes,
# Calculate Democratic and Republican vote percentages
pct_dem = d_votes/total,
pct_rep = r_votes/total,
# Calculate lean
d_points = pct_dem - pct_rep)
# Drop everything except the lean, county ID, and the election years
gov_updated <- gov_updated |>
select(election_year, GEOID, d_points, geometry)
# Bind the newer gubernatorial data onto the older data
gov3 <- rbind(gov2, gov_updated)
p <- ggplot(gov3, aes(fill = d_points, geometry = geometry)) +
geom_sf(color = "grey2", linewidth = 0.05) +
scale_fill_gradient2(
low = "#CB454A", mid = "white", high = "#2E74C0",
midpoint = 0,
name = "Partisan Lean"
) +
facet_wrap(~ election_year, ncol = 3) +
labs(title = "Partisan Lean in Gubernatorial Elections, 2005–2025") +
theme_minimal() +
theme(
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 16, face = "bold")
)
p
ggsave("figures/gov.png", plot = p, dpi = 300)
load("data/dataverse_shareable_us_senate_county_returns_1908_2020.Rdata")
# Filter down to just NJ results
senate <- senate_elections_release |>
filter(sfips == 34)
# Check what years are included
# unique(senate$election_year)
# Okay, that goes up until 2020. Does not capture Andy Kim's election in 2024
# Specify which years we are interested in
years <- c(2000, 2002, 2006, 2008, 2012, 2013, 2014, 2018, 2020)
# Select the interesting categories
senate <- senate |>
select(election_year, fips, sfips, office,
democratic_raw_votes, republican_raw_votes,
senate_raw_county_vote_totals_two_party)
# Select for the right years
senate <- senate |>
filter(election_year %in% years)
# Double check that there are only senate elections left
# unique(senate$office)
# Drop some columns and filter to NJ only
senate <- senate |>
filter(sfips == 34) |>
select(-office)
# Double check that the total two party vote number is correct
# sen1 <- senate |>
# mutate(total = democratic_raw_votes + republican_raw_votes,
# check = senate_raw_county_vote_totals_two_party - total)
# unique(sen1$check)
# Calculate the percent of Democrat and Republican votes and partisan lean
senate1 <- senate |>
mutate(pct_dem = democratic_raw_votes/senate_raw_county_vote_totals_two_party,
pct_rep = republican_raw_votes/senate_raw_county_vote_totals_two_party,
d_points = pct_dem - pct_rep)|>
# Drop everything except the lean, county ID, and the election years
select(election_year, fips, d_points) |>
# Rename the fips code for merging
rename(GEOID = fips)
# Isolate the geometry and fips code
geo <- county |>
select(GEOID, geometry)
# Add on the geometry to the election results
senate2 <- senate1 |>
left_join(geo, by = "GEOID")
p <- ggplot(senate2, aes(fill = d_points, geometry = geometry)) +
geom_sf(color = "grey2", linewidth = 0.05) +
scale_fill_gradient2(
low = "#CB454A", mid = "white", high = "#2E74C0",
midpoint = 0,
name = "Partisan Lean"
) +
facet_wrap(~ election_year, ncol = 3) +
labs(title = "Partisan Lean in Senate Elections, 2000–2020") +
theme_minimal() +
theme(
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 16, face = "bold")
)
p
ggsave("figures/senate.png", plot = p, dpi = 300)
gov_updated <- read.csv("data/updated_gov.csv")
# Rename the name category
gov_updated <- gov_updated |>
rename(NAME = county)
# Calculate the percent of Democrat and Republican votes and partisan lean
gov <- gov_updated |>
mutate(totals_two_party = d_votes + r_votes,
pct_dem = d_votes/totals_two_party,
pct_rep = r_votes/totals_two_party,
d_points = pct_dem - pct_rep)
# Read in the county shapefile data which is available from the Census (or the class drive)
county_all <- st_read("data/cb_2024_us_county_500k.shp")
# Filter to just New Jersey
geo <- county_all |>
filter(STATEFP == 34) |>
# Isolate the geometry, name and fips code
select(GEOID, geometry, NAME)
# Add on the geometry to the election results
gov2 <- gov %>%
left_join(geo, by = "NAME")
# Create the data set for ballot totals
map1 <- gov2 |>
filter(year == 2025) |>
select(totals_two_party, d_points, GEOID, geometry)
# Begin to graph the 2025 ballot count map from the AP
# Compute centroids of each county
map1 <- st_as_sf(map1)
county_centers <- st_centroid(map1)
p <- ggplot() +
# County outlines
geom_sf(data = map1, fill = NA, color = "grey2", linewidth = 0.05) +
# Add a dot at the county centers
geom_sf(data = county_centers, aes(color = d_points, size = totals_two_party), shape = 20) +
scale_color_gradient2(
low = "#D43D5A", mid = "white", high = "#2E75C9",
midpoint = 0,
name = "Partisan Lean"
) +
scale_size_continuous(
range = c(5, 17),   # adjust min/max dot size
name = "Ballots Counted"
) +
labs(title = "Ballots Counted") +
theme_minimal() +
theme(
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 16, face = "bold")
)
p
# The AP map also has two major cities
# Pull city coordinates
cities <- data.frame(
city = c("Newark", "Trenton"),
lon  = c(-74.1724, -74.7670),
lat  = c(40.7357, 40.2171)
)
# Convert to an sf object
cities_sf <- st_as_sf(cities, coords = c("lon", "lat"), crs = 4326)
# Make sure the projections match
cities_sf <- st_transform(cities_sf, st_crs(map1))
cities_coords <- st_coordinates(cities_sf)
cities_sf$X <- cities_coords[,1]
cities_sf$Y <- cities_coords[,2]
# add the cities to the map
p1 <- p +
geom_point(data = cities_sf, aes(x = X, y = Y, shape = city), color = "grey2", size = 2) +
geom_text(data = cities_sf,
aes(x = X, y = Y, label = city),
nudge_y = -0.07,
fontface = "bold",
size = 3) +
scale_shape_manual(values = c("Newark" = 15, "Trenton" = 8)) +
guides(shape = "none")
p1
ggsave("figures/2025ballotcount.png", plot = p1, dpi = 300)
map2 <- gov2 |>
select(year, pct_dem, pct_rep, GEOID, geometry)
# Pivot wider to have the counties as observations and vote percentages
# disaggregated by year
map2 <- map2 |>
pivot_wider(
names_from = year,
values_from = c(pct_dem, pct_rep)
)
# Calculate changes in pct rep and dem and then calculate vote margin
map2 <- map2 |>
mutate(
dem_change = pct_dem_2025 - pct_dem_2021,
rep_change = pct_rep_2025 - pct_rep_2021,
# Calculate shift towards democrats -- positive will indicate dem shift
shift = round(100*(dem_change - rep_change),1)
)
# Cull it to just the things we want to graph
map2 <- map2 |>
select(geometry, shift)
# Build the plot: convert the dataframe to an sf object
# Calculate the county centers
map2 <- st_as_sf(map2)
county_centers <- st_centroid(map2)
# Define a scaling factor
scaling_factor <- 50
# Create a data frame of arrow segments
arrows_df <- county_centers |>
mutate(
X = st_coordinates(geometry)[,1],
Y = st_coordinates(geometry)[,2],
shift_height = shift / scaling_factor,  # scale to fit map
Yend = Y + shift_height,
arrow_color = ifelse(shift >= 0, "#2E75C9", "#CC5E73")
)
# Plot with arrows
p <- ggplot() +
# County outlines
geom_sf(data = map2, fill = NA, color = "grey2", linewidth = 0.05) +
# Add the arrows
geom_segment(data = arrows_df,
aes(x = X, y = Y, xend = X, yend = Yend, color = arrow_color),
arrow = arrow(length = unit(0.15, "cm")),
linewidth = 1.2) +
scale_color_identity() +
theme_minimal() +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
plot.title = element_text(size = 16, face = "bold"))
p
# Remove the gridlines and add back on the cities
p1 <- p +
geom_point(data = cities_sf, aes(x = X, y = Y, shape = city), color = "grey2", size = 2) +
geom_text(data = cities_sf,
aes(x = X, y = Y, label = city),
nudge_y = -0.07,
fontface = "bold",
size = 3) +
scale_shape_manual(values = c("Newark" = 15, "Trenton" = 8)) +
theme(panel.grid = element_blank(),
legend.position = "none") +
labs(title = "Margin Shift")
p1
ggsave("figures/2025marginshift.png", plot = p1, dpi = 300)
race_full <- rbind(race_data_w, race_data10_w)
race_full <- rbind(race_full, race_data20_w)
# Now do some more manipulation to get at things like percentages
race_full1 <- race_full |>
# Create a variable that is just non-white
mutate(nonwhite = black + am.indian + asian + hawaii.pac.isl + other + two.more) |>
# Calculate percentages
mutate(pct_nonwhite = 100 * nonwhite / total,
pct_white = 100 * white / total,
pct_hisp = 100 * hisp.latino / total,
pct_black = 100 * black / total,
pct_am.indian = 100 * am.indian / total,
pct_asian = 100 * asian / total,
pct_hawaii.pac.isl = 100 * hawaii.pac.isl / total,
pct_other = 100 * other / total,
pct_two.more = 100 * two.more / total)
# Based on this, I sorted the various percentages and picked the racial/ethnic
# categories that looked most interesting to me
# Trim the dataset down to a more manageable set of variables to graph
race_full2 <- race_full1 |>
select(GEOID, NAME, year,
pct_asian, pct_nonwhite, pct_white, pct_hisp, pct_black)
# Add on geometry from the county file
geo <- county |>
select(GEOID, geometry)
race_full2 <- race_full2 |>
left_join(geo, by = "GEOID") |>
st_as_sf() # Make sure it remains an sf object so geometry can be recognized
# Round the percentages for the census data variables
race_full2 <- race_full2 |>
mutate(across(c(pct_asian, pct_nonwhite, pct_white, pct_hisp, pct_black),
round,
digits = 1))
# Rename the columns so that they can be used to title figures
race_full2 <- race_full2 |>
rename("Percent_White" = "pct_white",
"Percent_Nonwhite" = "pct_nonwhite",
"Percent_Black" = "pct_black",
"Percent_Hispanic_Latino" = "pct_hisp",
"Percent_Asian" = "pct_asian")
# Specify a group for the function to loop through
groups <- c("Percent_White", "Percent_Nonwhite", "Percent_Black",
"Percent_Hispanic_Latino", "Percent_Asian")
# Use a function to loop through the five demographic groups and graph their
# percentages on a scale from 0-100% by county
for (gp in groups) {
p  <- ggplot(race_full2, aes_string(fill = gp));
p1 <- p + geom_sf(color = "white", linewidth = 0.05) + coord_sf(datum = NA);
p2 <- p1 +
scale_fill_gradient(
limits = c(0, 100),
oob    = squish,
labels = label_number(scale_cut = cut_short_scale()),
low    = "beige",
high   = "maroon4"
) +
facet_wrap( ~ year, ncol = 3) +
labs(title = paste0(gp, ", 2000-2020"), fill = NULL); p2
p3 <- p2 +
theme_map() +
guides(fill = guide_colorbar(barheight = unit(60, "pt"))) +
theme(
panel.background = element_rect(fill = "white", color = NA),
plot.background  = element_rect(fill = "white", color = NA),
strip.background = element_blank(),                # remove gray bar
strip.text       = element_text(color = "black",
size = 12),   # plain black text
plot.title       = element_text(size = 16, face = "bold")
)
ggsave(filename = paste0("figures/", gp, "-100scale.png"),
plot = p3,
width = 8.5, height = 6, units = "in", dpi = 300)
}
full <- county |>
left_join(pop_full, by = "GEOID")
# Now clean up that data, calculate population density (by square mile not square meter)
full1 <- full |>
select(GEOID, NAME, year, ALAND, AWATER, population, geometry) |>
mutate(area = ALAND + AWATER,
density = population / ALAND * 2.59e+6)
# Identify the most populous and least populous counties in 2020
county_order <- full1 |>
arrange(desc(population))
most_pop <- county_order[1,2]
least_pop <- county_order[21,2]
# Identify the most dense and least dense (population) in 2020
county_order <- full1 |>
arrange(desc(density))
most_dense <- county_order[1,2]
least_dense <- county_order[21,2]
View(full1)
